<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://xiajuwei.github.io/my-blog/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/my-blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/my-blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/my-blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/my-blog/">Home</a>
        
          <a class="main-nav-link" href="/my-blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/my-blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xiajuwei.github.io/my-blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-lambda使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/12/02/lambda使用/" class="article-date">
  <time datetime="2019-12-02T06:26:54.000Z" itemprop="datePublished">2019-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/12/02/lambda使用/">lambda使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><em><code>一、引言</code></em></strong></p>
<p>java8最大的特性就是引入Lambda表达式，即函数式编程，可以将行为进行传递。总结就是：使用不可变值与函数，函数对不可变值进行处理，映射成另一个值。</p>
<p><strong><em><code>java重要的函数式接口</code></em></strong></p>
<p><strong><em><code>1、什么是函数式接口</code></em></strong></p>
<p>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</p>
<p>1.1 java8自带的常用函数式接口。</p>
<p><img src="/my-blog/2019/12/02/lambda使用/函数式接口.jpg" alt="接口"></p>
<pre><code>public class Test {
    public static void main(String[] args) {
        Predicate&lt;Integer&gt; predicate = x -&gt; x &gt; 185;
        Student student = new Student(&quot;9龙&quot;, 23, 175);
        System.out.println(
            &quot;9龙的身高高于185吗？：&quot; + predicate.test(student.getStature()));

        Consumer&lt;String&gt; consumer = System.out::println;
        consumer.accept(&quot;命运由我不由天&quot;);

        Function&lt;Student, String&gt; function = Student::getName;
        String name = function.apply(student);
        System.out.println(name);

        Supplier&lt;Integer&gt; supplier = 
            () -&gt; Integer.valueOf(BigDecimal.TEN.toString());
        System.out.println(supplier.get());

        UnaryOperator&lt;Boolean&gt; unaryOperator = uglily -&gt; !uglily;
        Boolean apply2 = unaryOperator.apply(true);
        System.out.println(apply2);

        BinaryOperator&lt;Integer&gt; operator = (x, y) -&gt; x * y;
        Integer integer = operator.apply(2, 3);
        System.out.println(integer);

        test(() -&gt; &quot;我是一个演示的函数式接口&quot;);
    }

    /**
     * 演示自定义函数式接口使用
     *
     * @param worker
     */
    public static void test(Worker worker) {
        String work = worker.work();
        System.out.println(work);
    }

    public interface Worker {
        String work();
    }
}
//9龙的身高高于185吗？：false
//命运由我不由天
//9龙
//10
//false
//6
//我是一个演示的函数式接口
</code></pre><p>以上演示了lambda接口的使用及自定义一个函数式接口并使用。下面，我们看看java8将函数式接口封装到流中如何高效的帮助我们处理集合。</p>
<p>注意：Student::getName例子中这种编写lambda表达式的方式称为方法引用。格式为ClassNmae::methodName。是不是很神奇，java8就是这么迷人。</p>
<pre><code>示例：本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。
</code></pre><p><img src="/my-blog/2019/12/02/lambda使用/class.webp" alt="接口"></p>
<p><strong><em><code>1.2 惰性求值与及早求值</code></em></strong></p>
<p>惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。</p>
<p>及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值。</p>
<p><strong><em><code>2、常用的流</code></em></strong><br>2.1 collect(Collectors.toList())<br>将流转换为list。还有toSet()，toMap()等。及早求值。</p>
<pre><code>public class TestCase {
    public static void main(String[] args) {
        List&lt;Student&gt; studentList = Stream.of(new Student(&quot;路飞&quot;, 22, 175),
                new Student(&quot;红发&quot;, 40, 180),
                new Student(&quot;白胡子&quot;, 50, 185)).collect(Collectors.toList());
        System.out.println(studentList);
    }
}
//输出结果
//[Student{name=&apos;路飞&apos;, age=22, stature=175, specialities=null}, 
//Student{name=&apos;红发&apos;, age=40, stature=180, specialities=null}, 
//Student{name=&apos;白胡子&apos;, age=50, stature=185, specialities=null}]
</code></pre><p>2.2 filter<br>顾名思义，起过滤筛选的作用。内部就是Predicate接口。惰性求值。<br><img src="/my-blog/2019/12/02/lambda使用/filter.webp" alt="接口"></p>
<p>比如我们筛选出出身高小于180的同学。</p>
<pre><code>public class TestCase {
    public static void main(String[] args) {
        List&lt;Student&gt; students = new ArrayList&lt;&gt;(3);
        students.add(new Student(&quot;路飞&quot;, 22, 175));
        students.add(new Student(&quot;红发&quot;, 40, 180));
        students.add(new Student(&quot;白胡子&quot;, 50, 185));

        List&lt;Student&gt; list = students.stream()
            .filter(stu -&gt; stu.getStature() &lt; 180)
            .collect(Collectors.toList());
        System.out.println(list);
    }
}
//输出结果
//[Student{name=&apos;路飞&apos;, age=22, stature=175, specialities=null}]
</code></pre><p>2.3 map<br>转换功能，内部就是Function接口。惰性求值<br><img src="/my-blog/2019/12/02/lambda使用/map.webp" alt="接口"></p>
<pre><code>public class TestCase {
    public static void main(String[] args) {
        List&lt;Student&gt; students = new ArrayList&lt;&gt;(3);
        students.add(new Student(&quot;路飞&quot;, 22, 175));
        students.add(new Student(&quot;红发&quot;, 40, 180));
        students.add(new Student(&quot;白胡子&quot;, 50, 185));

        List&lt;String&gt; names = students.stream().map(student -&gt; student.getName())
                .collect(Collectors.toList());
        System.out.println(names);
    }
}
//输出结果
//[路飞, 红发, 白胡子]
</code></pre><p>例子中将student对象转换为String对象，获取student的名字。</p>
<p>2.4 flatMap<br>将多个Stream合并为一个Stream。惰性求值<br><img src="/my-blog/2019/12/02/lambda使用/flatMap.webp" alt="接口"></p>
<pre><code>public class TestCase {
    public static void main(String[] args) {
        List&lt;Student&gt; students = new ArrayList&lt;&gt;(3);
        students.add(new Student(&quot;路飞&quot;, 22, 175));
        students.add(new Student(&quot;红发&quot;, 40, 180));
        students.add(new Student(&quot;白胡子&quot;, 50, 185));

        List&lt;Student&gt; studentList = Stream.of(students,
                asList(new Student(&quot;艾斯&quot;, 25, 183),
                        new Student(&quot;雷利&quot;, 48, 176)))
                .flatMap(students1 -&gt; students1.stream()).collect(Collectors.toList());
        System.out.println(studentList);
    }
}
//输出结果
//[Student{name=&apos;路飞&apos;, age=22, stature=175, specialities=null}, 
//Student{name=&apos;红发&apos;, age=40, stature=180, specialities=null}, 
//Student{name=&apos;白胡子&apos;, age=50, stature=185, specialities=null}, 
//Student{name=&apos;艾斯&apos;, age=25, stature=183, specialities=null},
//Student{name=&apos;雷利&apos;, age=48, stature=176, specialities=null}]
</code></pre><p>调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。</p>
<p>2.5 max和min<br>我们经常会在集合中求最大或最小值，使用流就很方便。及早求值</p>
<pre><code>public class TestCase {
    public static void main(String[] args) {
        List&lt;Student&gt; students = new ArrayList&lt;&gt;(3);
        students.add(new Student(&quot;路飞&quot;, 22, 175));
        students.add(new Student(&quot;红发&quot;, 40, 180));
        students.add(new Student(&quot;白胡子&quot;, 50, 185));

        Optional&lt;Student&gt; max = students.stream()
            .max(Comparator.comparing(stu -&gt; stu.getAge()));
        Optional&lt;Student&gt; min = students.stream()
            .min(Comparator.comparing(stu -&gt; stu.getAge()));
        //判断是否有值
        if (max.isPresent()) {
            System.out.println(max.get());
        }
        if (min.isPresent()) {
            System.out.println(min.get());
        }
    }
}
//输出结果
//Student{name=&apos;白胡子&apos;, age=50, stature=185, specialities=null}
//Student{name=&apos;路飞&apos;, age=22, stature=175, specialities=null}
</code></pre><p>max、min接收一个Comparator（例子中使用java8自带的静态函数，只需要传进需要比较值即可。）并且返回一个Optional对象，该对象是java8新增的类，专门为了防止null引发的空指针异常。</p>
<p>可以使用max.isPresent()判断是否有值；可以使用max.orElse(new Student())，当值为null时就使用给定值；也可以使用max.orElseGet(() -&gt; new Student());这需要传入一个Supplier的lambda表达式。</p>
<p>2.6 count<br>统计功能，一般都是结合filter使用，因为先筛选出我们需要的再统计即可。及早求值</p>
<pre><code>public class TestCase {
    public static void main(String[] args) {
        List&lt;Student&gt; students = new ArrayList&lt;&gt;(3);
        students.add(new Student(&quot;路飞&quot;, 22, 175));
        students.add(new Student(&quot;红发&quot;, 40, 180));
        students.add(new Student(&quot;白胡子&quot;, 50, 185));

        long count = students.stream().filter(s1 -&gt; s1.getAge() &lt; 45).count();
        System.out.println(&quot;年龄小于45岁的人数是：&quot; + count);
    }
}
//输出结果
//年龄小于45岁的人数是：2
</code></pre><p>2.7 reduce<br>reduce 操作可以实现从一组值中生成一个值。在上述例子中用到的 count 、 min 和 max 方法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。及早求值。<br><img src="/my-blog/2019/12/02/lambda使用/reduce.webp" alt="接口"></p>
<pre><code>public class TestCase {
    public static void main(String[] args) {
        Integer reduce = Stream.of(1, 2, 3, 4).reduce(0, (acc, x) -&gt; acc+ x);
        System.out.println(reduce);
    }
}
//输出结果
//10
</code></pre><p>我们看得reduce接收了一个初始值为0的累加器，依次取出值与累加器相加，最后累加器的值就是最终的结果。</p>
<p>三、高级集合类及收集器<br>3.1 转换成值<br>收集器，一种通用的、从流生成复杂值的结构。只要将它传给 collect 方法，所有的流就都可以使用它了。标准类库已经提供了一些有用的收集器，以下示例代码中的收集器都是从 java.util.stream.Collectors 类中静态导入的。</p>
<pre><code>public class CollectorsTest {
    public static void main(String[] args) {
        List&lt;Student&gt; students1 = new ArrayList&lt;&gt;(3);
        students1.add(new Student(&quot;路飞&quot;, 23, 175));
        students1.add(new Student(&quot;红发&quot;, 40, 180));
        students1.add(new Student(&quot;白胡子&quot;, 50, 185));

        OutstandingClass ostClass1 = new OutstandingClass(&quot;一班&quot;, students1);
        //复制students1，并移除一个学生
        List&lt;Student&gt; students2 = new ArrayList&lt;&gt;(students1);
        students2.remove(1);
        OutstandingClass ostClass2 = new OutstandingClass(&quot;二班&quot;, students2);
        //将ostClass1、ostClass2转换为Stream
        Stream&lt;OutstandingClass&gt; classStream = Stream.of(ostClass1, ostClass2);
        OutstandingClass outstandingClass = biggestGroup(classStream);
        System.out.println(&quot;人数最多的班级是：&quot; + outstandingClass.getName());

        System.out.println(&quot;一班平均年龄是：&quot; + averageNumberOfStudent(students1));
    }

    /**
     * 获取人数最多的班级
     */
    private static OutstandingClass biggestGroup(Stream&lt;OutstandingClass&gt; outstandingClasses) {
        return outstandingClasses.collect(
                maxBy(comparing(ostClass -&gt; ostClass.getStudents().size())))
                .orElseGet(OutstandingClass::new);
    }

    /**
     * 计算平均年龄
     */
    private static double averageNumberOfStudent(List&lt;Student&gt; students) {
        return students.stream().collect(averagingInt(Student::getAge));
    }
}
//输出结果
//人数最多的班级是：一班
//一班平均年龄是：37.666666666666664
</code></pre><p>maxBy或者minBy就是求最大值与最小值。<br>3.2 转换成块<br>常用的流操作是将其分解成两个集合，Collectors.partitioningBy帮我们实现了，接收一个Predicate函数式接口。<br><img src="/my-blog/2019/12/02/lambda使用/patition.webp" alt="接口"></p>
<p>将示例学生分为会唱歌与不会唱歌的两个集合。</p>
<pre><code>public class PartitioningByTest {
    public static void main(String[] args) {
        //省略List&lt;student&gt; students的初始化
        Map&lt;Boolean, List&lt;Student&gt;&gt; listMap = students.stream().collect(
            Collectors.partitioningBy(student -&gt; student.getSpecialities().
                                      contains(SpecialityEnum.SING)));
    }
}
</code></pre><p>3.3 数据分组<br>数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，可以使用任意值对数据分组。Collectors.groupingBy接收一个Function做转换。<br><img src="/my-blog/2019/12/02/lambda使用/group.webp" alt="接口"><br>如图，我们使用groupingBy将根据进行分组为圆形一组，三角形一组，正方形一组。</p>
<p>例子：根据学生第一个特长进行分组</p>
<pre><code>public class GroupingByTest {
    public static void main(String[] args) {
        //省略List&lt;student&gt; students的初始化
         Map&lt;SpecialityEnum, List&lt;Student&gt;&gt; listMap = 
             students.stream().collect(
             Collectors.groupingBy(student -&gt; student.getSpecialities().get(0)));
    }
}
</code></pre><p>Collectors.groupingBy与SQL 中的 group by 操作是一样的。</p>
<p>3.4 字符串拼接<br>如果将所有学生的名字拼接起来，怎么做呢？通常只能创建一个StringBuilder，循环拼接。使用Stream，使用Collectors.joining()简单容易。</p>
<pre><code>public class JoiningTest {
    public static void main(String[] args) {
        List&lt;Student&gt; students = new ArrayList&lt;&gt;(3);
        students.add(new Student(&quot;路飞&quot;, 22, 175));
        students.add(new Student(&quot;红发&quot;, 40, 180));
        students.add(new Student(&quot;白胡子&quot;, 50, 185));

         String names = students.stream()
             .map(Student::getName).collect(Collectors.joining(&quot;,&quot;,&quot;[&quot;,&quot;]&quot;));
        System.out.println(names);
    }
}
//输出结果
//[路飞,红发,白胡子]
</code></pre><p>joining接收三个参数，第一个是分界符，第二个是前缀符，第三个是结束符。也可以不传入参数Collectors.joining()，这样就是直接拼接。</p>
<p>四、总结<br>本篇主要从实际使用讲述了常用的方法及流，使用java8可以很清晰表达你要做什么，代码也很简洁。本篇例子主要是为了讲解较为简单，大家可以去使用java8重构自己现有的代码，自行领会lambda的奥妙。</p>
<p>本文说的Stream要组合使用才会发挥更大的功能，链式调用很迷人，根据自己的业务去做吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xiajuwei.github.io/my-blog/2019/12/02/lambda使用/" data-id="ck3o7yf020003m8vcftf59f23" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/12/02/hello-world/" class="article-date">
  <time datetime="2019-12-02T03:58:28.903Z" itemprop="datePublished">2019-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/12/02/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<p><strong><em><code>聊聊话题</code></em></strong></p>
<p>1.系统框架结构  </p>
<p>2.注册中心集群高可用、配置中心、消息总线、执行器更新配置（actuator）、zuul、feign,</p>
<p>3.peer配置注册中心，配置中心结合git,消息总线(mq)分布式系统发布、根据bus_id指定特定服务更新(暴露端口 refresh/env{key,value})，执行器根据id更新(@RefreshScope)，zuul路由配置，feign负载熔断，</p>
<p>4.不停机发布实现，</p>
<p>5.rabbitmq注解驱动的方式声明Queue、Exchange(type{direct,topic,fanout,heads}),bean注解方式声明</p>
<p>6.项目自动构建工具maven、gradle</p>
<p>7.系统使用策略模式，</p>
<p>8.学习分享</p>
<p>9.阅读源码</p>
<p>10.技术限制</p>
<p>11.系统中锁的应用</p>
<p>12.系统中检查代码工具</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xiajuwei.github.io/my-blog/2019/12/02/hello-world/" data-id="ck3o7yezy0001m8vca8zsxvba" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="idea-常用插件" class="article article-type-idea" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/08/10/常用插件/" class="article-date">
  <time datetime="2019-08-10T10:26:00.000Z" itemprop="datePublished">2019-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/08/10/常用插件/">常用插件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>idea 常用插件</p>
<p><img src="/my-blog/2019/08/10/常用插件/idea插件.jpg" alt="插件"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xiajuwei.github.io/my-blog/2019/08/10/常用插件/" data-id="ck3o7yf090008m8vcstq2nvs2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/07/02/redis/" class="article-date">
  <time datetime="2019-07-02T10:25:29.000Z" itemprop="datePublished">2019-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/07/02/redis/">redis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>redis 配置 redis.conf  启动配置文件</p>
<p>redis 修改RedisTemplate的序列化策略。<br><a href="https://blog.csdn.net/qq_33764491/article/details/80955772" target="_blank" rel="noopener">https://blog.csdn.net/qq_33764491/article/details/80955772</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xiajuwei.github.io/my-blog/2019/07/02/redis/" data-id="ck3o7yf030004m8vc4zs206re" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-中的锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/06/20/java-中的锁/" class="article-date">
  <time datetime="2019-06-20T07:19:51.000Z" itemprop="datePublished">2019-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/06/20/java-中的锁/">java 中的锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.分布式锁Spring Integration（企业集成模式）</p>
<p>Spring Integration提供的全局锁目前为如下存储提供了实现：</p>
<p>•Gemfire<br>•JDBC<br>•Redis<br>•Zookeeper</p>
<p>它们使用相同的API抽象——这正是Spring最擅长的。这意味着，不论使用哪种存储，你的编码体验是一样的，有一天想更换实现，只需要修改依赖和配置就可以了，无需修改代码。</p>
<p>1.RedisLockRegistry</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-integration&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
  &lt;artifactId&gt;spring-integration-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>2.ZookeeperLockRegistry </p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-zookeeper&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>锁的使用：</p>
<pre><code>import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.integration.redis.util.RedisLockRegistry;

@Configuration
public class RedisLockConfiguration {
    @Bean
    public RedisLockRegistry redisLockRegistry(RedisConnectionFactory redisConnectionFactory) {

        RedisLockRegistry redisLockRegistry = new RedisLockRegistry(redisConnectionFactory, &quot;spring-redis&quot;);

        return redisLockRegistry;
    }

}
</code></pre><p>两种分布式锁都继承来LockRegistry。故可通过LockRegistry来申明变量，获取锁</p>
<pre><code>Lock lock = redisLockRegistry.obtain(lockKey);
try {
    log.info(&quot;开始争抢锁 &quot;);
    if (lock.tryLock(3, TimeUnit.SECONDS)) {
    //争抢到锁 
    log.info(&quot;争抢到锁 &quot;);
     // do business
    }
} catch (Exception e) {
    log.error(&quot;获取锁失败 ： &quot;, e);
} finally {
    lock.unlock();
}
</code></pre><p><img src="/my-blog/2019/06/20/java-中的锁/lock封装的常用api.png" alt="api"></p>
<p>基于表记录<br>    要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们想要获得锁的时候，就可以在该表中增加一条记录，想要释放锁的时候就删除这条记录。<br>为了更好的演示，我们先创建一张数据库表，参考如下：</p>
<pre><code>CREATE TABLE `database_lock` (
    `id` BIGINT NOT NULL AUTO_INCREMENT,
    `resource` int NOT NULL COMMENT &apos;锁定的资源&apos;,
    `description` varchar(1024) NOT NULL DEFAULT &quot;&quot; COMMENT &apos;描述&apos;,
    PRIMARY KEY (`id`),
    UNIQUE KEY `uiq_idx_resource` (`resource`) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&apos;数据库分布式锁表&apos;;
</code></pre><p>当我们想要获得锁时，可以插入一条数据：</p>
<pre><code>INSERT INTO database_lock(resource, description) VALUES (1, &apos;lock&apos;);
</code></pre><p>注意：在表database_lock中，resource字段做了唯一性约束，这样如果有多个请求同时提交到数据库的话，数据库可以保证只有一个操作可以成功（其它的会报错：ERROR 1062 (23000): Duplicate entry ‘1’ for key ‘uiq_idx_resource’），那么那么我们就可以认为操作成功的那个请求获得了锁。</p>
<p>当需要释放锁的时，可以删除这条数据：</p>
<pre><code>DELETE FROM database_lock WHERE resource=1;
</code></pre><p>这种实现方式非常的简单，但是需要注意以下几点：</p>
<p>这种锁没有失效时间，一旦释放锁的操作失败就会导致锁记录一直在数据库中，其它线程无法获得锁。这个缺陷也很好解决，比如可以做一个定时任务去定时清理。<br>这种锁的可靠性依赖于数据库。建议设置备库，避免单点，进一步提高可靠性。<br>这种锁是非阻塞的，因为插入数据失败之后会直接报错，想要获得锁就需要再次操作。如果需要阻塞式的，可以弄个for循环、while循环之类的，直至INSERT成功再返回。<br>这种锁也是非可重入的，因为同一个线程在没有释放锁之前无法再次获得锁，因为数据库中已经存在同一份记录了。想要实现可重入锁，可以在数据库中添加一些字段，比如获得锁的主机信息、线程信息等，那么在再次获得锁的时候可以先查询数据，如果当前的主机信息和线程信息等能被查到的话，可以直接把锁分配给它。</p>
<p>乐观锁<br>    系统认为数据的更新的大多数情况下就不会产生冲突的，只在数据库更新操作提交的时候才对数据作冲突检查，如果检测的结果出现了与预期数据不一致的情况，则返回失败信息。<br>乐观锁的优点比较明显，由于在检测数据冲突时并不依赖数据库本身的锁机制，不会影响请求的性能，当产生并发且并发量较小的时候只有少部分请求会失败。缺点是需要对表的设计增加额外的字段，增加了数据库的冗余，另外，当应用并发量高的时候，version值在频繁变化，则会导致大量请求失败，影响系统的可用性。我们通过上述sql语句还可以看到，数据库锁都是作用于同一行数据记录上，这就导致一个明显的缺点，在一些特殊场景，如大促、秒杀等活动开展的时候，大量的请求同时请求同一条记录的行锁，会对数据库产生很大的写压力。所以综合数据库乐观锁的优缺点，乐观锁比较适合并发量不高，并且写操作不频繁的场景。</p>
<p><strong><em><code>悲观锁</code></em></strong></p>
<p>除了可以通过增删操作数据库表中的记录以外，我们还可以借助数据库中自带的锁来实现分布式锁。在查询语句后面增加FOR UPDATE，数据库会在查询过程中给数据库表增加悲观锁，也称排他锁。当某条记录被加上悲观锁之后，其它线程也就无法再改行上增加悲观锁。</p>
<p>悲观锁，与乐观锁相反，总是假设最坏的情况，它认为数据的更新在大多数情况下是会产生冲突的。</p>
<p>在使用悲观锁的同时，我们需要注意一下锁的级别。MySQL InnoDB引起在加锁的时候，只有明确地指定主键(或索引)的才会执行行锁 (只锁住被选取的数据)，否则MySQL 将会执行表锁(将整个数据表单给锁住)。</p>
<p>在使用悲观锁时，我们必须关闭MySQL数据库的自动提交属性（参考下面的示例），因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。</p>
<pre><code>mysql&gt; SET AUTOCOMMIT = 0;
Query OK, 0 rows affected (0.00 sec)
</code></pre><p>这样在使用FOR UPDATE获得锁之后可以执行相应的业务逻辑，执行完之后再使用COMMIT来释放锁。</p>
<p>我们不妨沿用前面的database_lock表来具体表述一下用法。假设有一线程A需要获得锁并执行相应的操作，那么它的具体步骤如下：</p>
<p>STEP1获取锁：SELECT * FROM database_lock WHERE id = 1 FOR UPDATE;。<br>STEP2执行业务逻辑。<br>STEP3释放锁：COMMIT。<br>如果另一个线程B在线程A释放锁之前执行STEP1，那么它会被阻塞，直至线程A释放锁之后才能继续。注意，如果线程A长时间未释放锁，那么线程B会报错，参考如下（lock wait time可以通过innodb_lock_wait_timeout来进行配置）：</p>
<pre><code>ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</code></pre><p>上面的示例中演示了指定主键并且能查询到数据的过程（触发行锁），如果查不到数据那么也就无从“锁”起了。</p>
<p>如果未指定主键（或者索引）且能查询到数据，那么就会触发表锁，比如STEP1改为执行（这里的version只是当做一个普通的字段来使用，与上面的乐观锁无关）：</p>
<pre><code>SELECT * FROM database_lock WHERE description=&apos;lock&apos; FOR UPDATE;
</code></pre><p>或者主键不明确也会触发表锁，又比如STEP1改为执行：</p>
<pre><code>SELECT * FROM database_lock WHERE id&gt;0 FOR UPDATE;
</code></pre><p>注意，虽然我们可以显示使用行级锁（指定可查询的主键或索引），但是MySQL会对查询进行优化，即便在条件中使用了索引字段，但是否真的使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它有可能不会使用索引，在这种情况下InnoDB将使用表锁，而不是行锁。</p>
<p>在悲观锁中，每一次行数据的访问都是独占的，只有当正在访问该行数据的请求事务提交以后，其他请求才能依次访问该数据，否则将阻塞等待锁的获取。悲观锁可以严格保证数据访问的安全。但是缺点也明显，即每次请求都会额外产生加锁的开销且未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，容易造成大量请求阻塞，影响系统可用性。另外，悲观锁使用不当还可能产生死锁的情况。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xiajuwei.github.io/my-blog/2019/06/20/java-中的锁/" data-id="ck3o7yf0b0009m8vcfcin376f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-详解java-nio" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/06/17/详解java-nio/" class="article-date">
  <time datetime="2019-06-17T10:00:17.000Z" itemprop="datePublished">2019-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/06/17/详解java-nio/">详解java nio</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p>
<p>NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<p>IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<p><strong><em><code>Channel</code></em></strong></p>
<p>首先说一下Channel，国内大多翻译成“通道”。Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream, OutputStream.而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO中的Channel的主要实现有：</p>
<p>FileChannel<br>DatagramChannel<br>SocketChannel<br>ServerSocketChannel<br>这里看名字就可以猜出个所以然来：分别可以对应文件IO、UDP和TCP（Server和Client）。下面演示的案例基本上就是围绕这4个类型的Channel进行陈述的。</p>
<p><strong><em><code>Buffer</code></em></strong></p>
<p>NIO中的关键Buffer实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short。当然NIO中还有MappedByteBuffer, HeapByteBuffer, DirectByteBuffer等这里先不进行陈述。</p>
<p><strong><em><code>Selector</code></em></strong></p>
<p>Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。</p>
<p><strong><em><code>传统IO vs NIO</code></em></strong></p>
<p>首先，案例1是采用FileInputStream读取文件内容的：</p>
<pre><code>public static void method2(){
    InputStream in = null;
    try{
        in = new BufferedInputStream(new FileInputStream(&quot;src/nomal_io.txt&quot;));
        byte [] buf = new byte[1024];
        int bytesRead = in.read(buf);
        while(bytesRead != -1)
        {
            for(int i=0;i&lt;bytesRead;i++)
                System.out.print((char)buf[i]);
            bytesRead = in.read(buf);
        }
    }catch (IOException e)
    {
        e.printStackTrace();
    }finally{
        try{
            if(in != null){
                in.close();
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre><p>案例是对应的NIO（这里通过RandomAccessFile进行操作，当然也可以通过FileInputStream.getChannel()进行操作）：</p>
<pre><code>public static void method1(){
    RandomAccessFile aFile = null;
    try{
        aFile = new RandomAccessFile(&quot;src/nio.txt&quot;,&quot;rw&quot;);
        FileChannel fileChannel = aFile.getChannel();
        ByteBuffer buf = ByteBuffer.allocate(1024);
        int bytesRead = fileChannel.read(buf);
        System.out.println(bytesRead);
        while(bytesRead != -1)
        {
            buf.flip();
            while(buf.hasRemaining())
            {
                System.out.print((char)buf.get());
            }
            buf.compact();
            bytesRead = fileChannel.read(buf);
        }
    }catch (IOException e){
        e.printStackTrace();
    }finally{
        try{
            if(aFile != null){
                aFile.close();
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre><p>从案例2中可以总结出使用Buffer一般遵循下面几个步骤：</p>
<p>分配空间（ByteBuffer buf = ByteBuffer.allocate(1024); 还有一种allocateDirector后面再陈述）<br>写入数据到Buffer(int bytesRead = fileChannel.read(buf);)<br>调用filp()方法（ buf.flip();）<br>从Buffer中读取数据（System.out.print((char)buf.get());）<br>调用clear()方法或者compact()方法<br>Buffer顾名思义：缓冲区，实际上是一个容器，一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读写的数据都必须经过Buffer。</p>
<p>向Buffer中写数据：</p>
<p>从Channel写到Buffer (fileChannel.read(buf))<br>通过Buffer的put()方法 （buf.put(…)）<br>从Buffer中读取数据：</p>
<p>从Buffer读取到Channel (channel.write(buf))<br>使用get()方法从Buffer中读取数据 （buf.get()）<br>可以把Buffer简单地理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态：capacity, position, limit, mark：</p>
<p><img src="/my-blog/2019/06/17/详解java-nio/buffer.png" alt="buffer"></p>
<p>举例：我们通过ByteBuffer.allocate(11)方法创建了一个11个byte的数组的缓冲区，初始状态如上图，position的位置为0，capacity和limit默认都是数组长度。当我们写入5个字节时，变化如下图：</p>
<p><img src="/my-blog/2019/06/17/详解java-nio/1.png" alt="buffer"></p>
<p>这时我们需要将缓冲区中的5个字节数据写入Channel的通信信道，所以我们调用ByteBuffer.flip()方法，变化如下图所示(position设回0，并将limit设成之前的position的值)：</p>
<p><img src="/my-blog/2019/06/17/详解java-nio/2.jpg" alt="buffer"></p>
<p>这时底层操作系统就可以从缓冲区中正确读取这个5个字节数据并发送出去了。在下一次写数据之前我们再调用clear()方法，缓冲区的索引位置又回到了初始位置。</p>
<p>调用clear()方法：position将被设回0，limit设置成capacity，换句话说，Buffer被清空了，其实Buffer中的数据并未被清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用compact()方法。compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>
<p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定的position，之后可以通过调用Buffer.reset()方法恢复到这个position。Buffer.rewind()方法将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素。</p>
<p><strong><em><code>内存映射文件</code></em></strong></p>
<p>JAVA处理大文件，一般用BufferedReader,BufferedInputStream这类带缓冲的IO类，不过如果文件超大的话，更快的方式是采用MappedByteBuffer。</p>
<p>MappedByteBuffer是NIO引入的文件内存映射方案，读写性能极高。NIO最主要的就是实现了对异步操作的支持。其中一种通过把一个套接字通道(SocketChannel)注册到一个选择器(Selector)中,不时调用后者的选择(select)方法就能返回满足的选择键(SelectionKey),键中包含了SOCKET事件信息。这就是select模型。</p>
<p>SocketChannel的读写是通过一个类叫ByteBuffer来操作的.这个类本身的设计是不错的,比直接操作byte[]方便多了. ByteBuffer有两种模式:直接/间接.间接模式最典型(也只有这么一种)的就是HeapByteBuffer,即操作堆内存 (byte[]).但是内存毕竟有限,如果我要发送一个1G的文件怎么办?不可能真的去分配1G的内存.这时就必须使用”直接”模式,即 MappedByteBuffer,文件映射.</p>
<p>先中断一下,谈谈操作系统的内存管理.一般操作系统的内存分两部分:物理内存;虚拟内存.虚拟内存一般使用的是页面映像文件,即硬盘中的某个(某些)特殊的文件.操作系统负责页面文件内容的读写,这个过程叫”页面中断/切换”. MappedByteBuffer也是类似的,你可以把整个文件(不管文件有多大)看成是一个ByteBuffer.MappedByteBuffer 只是一种特殊的ByteBuffer，即是ByteBuffer的子类。 MappedByteBuffer 将文件直接映射到内存（这里的内存指的是虚拟内存，并不是物理内存）。通常，可以映射整个文件，如果文件比较大的话可以分段进行映射，只要指定文件的那个部分就可以。</p>
<p><code>概念</code></p>
<p>FileChannel提供了map方法来把文件影射为内存映像文件： MappedByteBuffer map(int mode,long position,long size); 可以把文件的从position开始的size大小的区域映射为内存映像文件，mode指出了 可访问该内存映像文件的方式：</p>
<p>READ_ONLY,（只读）： 试图修改得到的缓冲区将导致抛出 ReadOnlyBufferException.(MapMode.READ_ONLY)<br>READ_WRITE（读/写）： 对得到的缓冲区的更改最终将传播到文件；该更改对映射到同一文件的其他程序不一定是可见的。 (MapMode.READ_WRITE)<br>PRIVATE（专用）： 对得到的缓冲区的更改不会传播到文件，并且该更改对映射到同一文件的其他程序也不是可见的；相反，会创建缓冲区已修改部分的专用副本。 (MapMode.PRIVATE)<br>MappedByteBuffer是ByteBuffer的子类，其扩充了三个方法：</p>
<p>force()：缓冲区是READ_WRITE模式下，此方法对缓冲区内容的修改强行写入文件；<br>load()：将缓冲区的内容载入内存，并返回该缓冲区的引用；<br>isLoaded()：如果缓冲区的内容在物理内存中，则返回真，否则返回假；</p>
<p>这里通过采用ByteBuffer和MappedByteBuffer分别读取大小约为5M的文件”src/1.ppt”来比较两者之间的区别，method3()是采用MappedByteBuffer读取的，method4()对应的是ByteBuffer。</p>
<pre><code>public static void method4(){
    RandomAccessFile aFile = null;
    FileChannel fc = null;
    try{
        aFile = new RandomAccessFile(&quot;src/1.ppt&quot;,&quot;rw&quot;);
        fc = aFile.getChannel();
        long timeBegin = System.currentTimeMillis();
        ByteBuffer buff = ByteBuffer.allocate((int) aFile.length());
        buff.clear();
        fc.read(buff);
        //System.out.println((char)buff.get((int)(aFile.length()/2-1)));
        //System.out.println((char)buff.get((int)(aFile.length()/2)));
        //System.out.println((char)buff.get((int)(aFile.length()/2)+1));
        long timeEnd = System.currentTimeMillis();
        System.out.println(&quot;Read time: &quot;+(timeEnd-timeBegin)+&quot;ms&quot;);
    }catch(IOException e){
        e.printStackTrace();
    }finally{
        try{
            if(aFile!=null){
                aFile.close();
            }
            if(fc!=null){
                fc.close();
            }
        }catch(IOException e){
            e.printStackTrace();
        }
    }
}
public static void method3(){
    RandomAccessFile aFile = null;
    FileChannel fc = null;
    try{
        aFile = new RandomAccessFile(&quot;src/1.ppt&quot;,&quot;rw&quot;);
        fc = aFile.getChannel();
        long timeBegin = System.currentTimeMillis();
        MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_ONLY, 0, aFile.length());
        // System.out.println((char)mbb.get((int)(aFile.length()/2-1)));
        // System.out.println((char)mbb.get((int)(aFile.length()/2)));
        //System.out.println((char)mbb.get((int)(aFile.length()/2)+1));
        long timeEnd = System.currentTimeMillis();
        System.out.println(&quot;Read time: &quot;+(timeEnd-timeBegin)+&quot;ms&quot;);
    }catch(IOException e){
        e.printStackTrace();
    }finally{
        try{
            if(aFile!=null){
                aFile.close();
            }
            if(fc!=null){
                fc.close();
            }
        }catch(IOException e){
            e.printStackTrace();
        }
    }
}

_注：MappedByteBuffer有资源释放的问题：被MappedByteBuffer打开的文件只有在垃圾收集时才会被关闭，而这个点是不确定的。在Javadoc中这里描述：A mapped byte buffer and the file mapping that it represents remian valid until the buffer itself is garbage-collected。详细可以翻阅参考资料5和6._
</code></pre><p><code>transferFrom &amp; transferTo</code><br>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中。</p>
<pre><code>public static void method1(){
    RandomAccessFile fromFile = null;
    RandomAccessFile toFile = null;
    try
    {
        fromFile = new RandomAccessFile(&quot;src/fromFile.xml&quot;,&quot;rw&quot;);
        FileChannel fromChannel = fromFile.getChannel();
        toFile = new RandomAccessFile(&quot;src/toFile.txt&quot;,&quot;rw&quot;);
        FileChannel toChannel = toFile.getChannel();
        long position = 0;
        long count = fromChannel.size();
        System.out.println(count);
        toChannel.transferFrom(fromChannel, position, count);
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
    finally{
        try{
            if(fromFile != null){
                fromFile.close();
            }
            if(toFile != null){
                toFile.close();
            }
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre><p>方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p>
<p>transferTo()方法将数据从FileChannel传输到其他的channel中。</p>
<pre><code>public static void method2()
{
    RandomAccessFile fromFile = null;
    RandomAccessFile toFile = null;
    try
    {
        fromFile = new RandomAccessFile(&quot;src/fromFile.txt&quot;,&quot;rw&quot;);
        FileChannel fromChannel = fromFile.getChannel();
        toFile = new RandomAccessFile(&quot;src/toFile.txt&quot;,&quot;rw&quot;);
        FileChannel toChannel = toFile.getChannel();
        long position = 0;
        long count = fromChannel.size();
        System.out.println(count);
        fromChannel.transferTo(position, count,toChannel);
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
    finally{
        try{
            if(fromFile != null){
                fromFile.close();
            }
            if(toFile != null){
                toFile.close();
            }
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre><p> 上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xiajuwei.github.io/my-blog/2019/06/17/详解java-nio/" data-id="ck3o7yf18000cm8vco2cqi4k4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-十大排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/06/14/十大排序算法/" class="article-date">
  <time datetime="2019-06-14T09:23:20.000Z" itemprop="datePublished">2019-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/06/14/十大排序算法/">十大排序算法--动态图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>since:<br><a href="https://mp.weixin.qq.com/s/D0-lOLFkfppTnvN9yK_lBg" target="_blank" rel="noopener">公众号</a> </p>
<p><strong><em><code>No.1 冒泡排序</code></em></strong></p>
<p>冒泡排序无疑是最为出名的排序算法之一，从序列的一端开始往另一端冒泡（你可以从左往右冒泡，也可以从右往左冒泡，看心情），依次比较相邻的两个数的大小（到底是比大还是比小也看你心情）。<br><img src="/my-blog/2019/06/14/十大排序算法/冒泡动态图.gif" alt="排序"></p>
<pre><code>以 [ 8，2，5，9，7 ] 这组数字来做示例
public static void sort(int arr[]){
    for( int i = 0 ; i &lt; arr.length - 1 ; i++ ){
        for(int j = 0;j &lt; arr.length - 1 - i ; j++){
            int temp = 0;
            if(arr[j] &lt; arr[j + 1]){
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
</code></pre><p>冒泡的代码还是相当简单的，两层循环，外层冒泡轮数，里层依次比较，江湖中人人尽皆知。</p>
<p>我们看到嵌套循环，应该立马就可以得出这个算法的时间复杂度为O(n2)。</p>
<p>冒泡有一个最大的问题就是这种算法不管不管你有序还是没序，闭着眼睛把你循环比较了再说。</p>
<p>比如我举个数组例子：[ 9，8，7，6，5 ]，一个有序的数组，根本不需要排序，它仍然是双层循环一个不少的把数据遍历干净，这其实就是做了没必要做的事情，属于浪费资源。</p>
<p>针对这个问题，我们可以设定一个临时遍历来标记该数组是否已经有序，如果有序了就不用遍历了。</p>
<pre><code>public static void sort(int arr[]){
    for( int i = 0;i &lt; arr.length - 1 ; i++ ){
        boolean isSort = true;
        for( int j = 0;j &lt; arr.length - 1 - i ; j++ ){
            int temp = 0;
            if(arr[j] &lt; arr[j + 1]){
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                isSort = false;
            }
        }
        if(isSort){
            break;
        }
    }
}
</code></pre><p><strong><em><code>No.2 选择排序</code></em></strong></p>
<p>选择排序的思路是这样的：首先，找到数组中最小的元素，拎出来，将它和数组的第一个元素交换位置，第二步，在剩下的元素中继续寻找最小的元素，拎出来，和数组的第二个元素交换位置，如此循环，直到整个数组排序完成。</p>
<p>至于选大还是选小，这个都无所谓，你也可以每次选择最大的拎出来排，也可以每次选择最小的拎出来的排，只要你的排序的手段是这种方式，都叫选择排序。</p>
<p><img src="/my-blog/2019/06/14/十大排序算法/选择排序.gif" alt="排序"></p>
<pre><code>我们还是以[ 8，2，5，9，7 ]这组数字做例子
public static void sort(int arr[]){
    for( int i = 0;i &lt; arr.length ; i++ ){
        int min = i;//最小元素的下标
        for(int j = i + 1;j &lt; arr.length ; j++ ){
            if(arr[j] &lt; arr[min]){
                min = j;//找最小值
            }
        }
        //交换位置
        int temp = arr[i];
        arr[i] = arr[min];
        arr[min] = temp;
    }
}
</code></pre><p>双层循环，时间复杂度和冒泡一模一样，都是O(n2)。</p>
<p><strong><em><code>No.3 插入排序</code></em></strong></p>
<p>插入排序的思想和我们打扑克摸牌的时候一样，从牌堆里一张一张摸起来的牌都是乱序的，我们会把摸起来的牌插入到左手中合适的位置，让左手中的牌时刻保持一个有序的状态。</p>
<p>那如果我们不是从牌堆里摸牌，而是左手里面初始化就是一堆乱牌呢？ 一样的道理，我们把牌往手的右边挪一挪，把手的左边空出一点位置来，然后在乱牌中抽一张出来，插入到左边，再抽一张出来，插入到左边，再抽一张，插入到左边，每次插入都插入到左边合适的位置，时刻保持左边的牌是有序的，直到右边的牌抽完，则排序完毕。<br><img src="/my-blog/2019/06/14/十大排序算法/插入排序.gif" alt="排序"></p>
<pre><code>数组初始化：[ 8，2，5，9，7 ]
public static void sort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i &lt; n; ++i) {
        int value = arr[i];
        int j = 0;//插入的位置
        for (j = i-1; j &gt;= 0; j--) {
            if (arr[j] &gt; value) {
                arr[j+1] = arr[j];//移动数据
            } else {
                break;
            }
        }
        arr[j+1] = value; //插入数据
    }
}
</code></pre><p>从代码里我们可以看出，如果找到了合适的位置，就不会再进行比较了，就好比牌堆里抽出的一张牌本身就比我手里的牌都小，那么我只需要直接放在末尾就行了，不用一个一个去移动数据腾出位置插入到中间。</p>
<p>所以说，最好情况的时间复杂度是 O(n)，最坏情况的时间复杂度是 O(n2)，然而时间复杂度这个指标看的是最坏的情况，而不是最好的情况，所以插入排序的时间复杂度是 O(n2)。</p>
<p><strong><em><code>No.4 希尔排序</code></em></strong></p>
<p>希尔排序这个名字，来源于它的发明者希尔，也称作“缩小增量排序”，是插入排序的一种更高效的改进版本。</p>
<p>我们知道，插入排序对于大规模的乱序数组的时候效率是比较慢的，因为它每次只能将数据移动一位，希尔排序为了加快插入的速度，让数据移动的时候可以实现跳跃移动，节省了一部分的时间开支。<br><img src="/my-blog/2019/06/14/十大排序算法/希尔排序.gif" alt="排序"></p>
<pre><code>数组初始化：[ 8,9,1,7,2,3,5,4,6,0 ]
public static void sort(int[] arr) {
    int length = arr.length;
    //区间
    int gap = 1;
    while (gap &lt; length) {
        gap = gap * 3 + 1;
    }
    while (gap &gt; 0) {
        for (int i = gap; i &lt; length; i++) {
            int tmp = arr[i];
            int j = i - gap;
            //跨区间排序
            while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) {
                arr[j + gap] = arr[j];
                j -= gap;
            }
            arr[j + gap] = tmp;
        }
        gap = gap / 3;
    }
}
</code></pre><p>可能你会问为什么区间要以 gap = gap*3 + 1 去计算，其实最优的区间计算方法是没有答案的，这是一个长期未解决的问题，不过差不多都会取在二分之一到三分之一附近。</p>
<p><strong><em><code>No.5 归并排序</code></em></strong></p>
<p>归并字面上的意思是合并，归并算法的核心思想是分治法，就是将一个数组一刀切两半，递归切，直到切成单个元素，然后重新组装合并，单个元素合并成小数组，两个小数组合并成大数组，直到最终合并完成，排序完毕。</p>
<p>我们上面讲过，归并排序的核心思想是分治，分而治之，将一个大问题分解成无数的小问题进行处理，处理之后再合并，这里我们采用递归来实现：<br><img src="/my-blog/2019/06/14/十大排序算法/归并排序.gif" alt="排序"></p>
<pre><code>[ 8，2，5，9，7 ]
public static void sort(int[] arr) {
        int[] tempArr = new int[arr.length];
        sort(arr， tempArr， 0， arr.length-1);
}

/**
 * 归并排序
 * @param arr 排序数组
 * @param tempArr 临时存储数组
 * @param startIndex 排序起始位置
 * @param endIndex 排序终止位置
 */
private static void sort(int[] arr，int[] tempArr，int startIndex，int endIndex){
    if(endIndex &lt;= startIndex){
        return;
    }
    //中部下标
    int middleIndex = startIndex + (endIndex - startIndex) / 2;

    //分解
    sort(arr，tempArr，startIndex，middleIndex);
    sort(arr，tempArr，middleIndex + 1，endIndex);

    //归并
    merge(arr，tempArr，startIndex，middleIndex，endIndex);
}

/**
 * 归并
 * @param arr 排序数组
 * @param tempArr 临时存储数组
 * @param startIndex 归并起始位置
 * @param middleIndex 归并中间位置
 * @param endIndex 归并终止位置
 */
private static void merge(int[] arr， int[] tempArr， int startIndex， int middleIndex， int endIndex) {
    //复制要合并的数据
    for (int s = startIndex; s &lt;= endIndex; s++) {
        tempArr[s] = arr[s];
    }

    int left = startIndex;//左边首位下标
    int right = middleIndex + 1;//右边首位下标
    for (int k = startIndex; k &lt;= endIndex; k++) {
        if(left &gt; middleIndex){
            //如果左边的首位下标大于中部下标，证明左边的数据已经排完了。
            arr[k] = tempArr[right++];
        } else if (right &gt; endIndex){
            //如果右边的首位下标大于了数组长度，证明右边的数据已经排完了。
            arr[k] = tempArr[left++];
        } else if (tempArr[right] &lt; tempArr[left]){
            arr[k] = tempArr[right++];//将右边的首位排入，然后右边的下标指针+1。
        } else {
            arr[k] = tempArr[left++];//将左边的首位排入，然后左边的下标指针+1。
        }
    }
}
</code></pre><p>我们可以发现 merge 方法中只有一个 for 循环，直接就可以得出每次合并的时间复杂度为 O(n) ，而分解数组每次对半切割，属于对数时间 O(log n) ，合起来等于 O(log2n) ，也就是说，总的时间复杂度为 O(nlogn) 。</p>
<p>关于空间复杂度，其实大部分人写的归并都是在 merge 方法里面申请临时数组，用临时数组来辅助排序工作，空间复杂度为 O(n)，而我这里做的是原地归并，只在最开始申请了一个临时数组，所以空间复杂度为 O(1)。</p>
<p>如果你对空间复杂度这一块不太了解，可以查看小吴之前的数据结构系列文章—冰与火之歌：「时间」与「空间」复杂度 。</p>
<p><code>_**No.6 快速排序**_</code></p>
<p> 快速排序的核心思想也是分治法，分而治之。它的实现方式是每次从序列中选出一个基准值，其他数依次和基准值做比较，比基准值大的放右边，比基准值小的放左边，然后再对左边和右边的两组数分别选出一个基准值，进行同样的比较移动，重复步骤，直到最后都变成单个元素，整个数组就成了有序的序列。<br> <img src="/my-blog/2019/06/14/十大排序算法/快速排序.gif" alt="排序"></p>
<pre><code>[ 8，2，5，0，7，4，6，1 ]
</code></pre><p>单边扫描：<br>快速排序的关键之处在于切分，切分的同时要进行比较和移动，这里介绍一种叫做单边扫描的做法。</p>
<p>我们随意抽取一个数作为基准值，同时设定一个标记 mark 代表左边序列最右侧的下标位置，当然初始为 0 ，接下来遍历数组，如果元素大于基准值，无操作，继续遍历，如果元素小于基准值，则把 mark + 1 ，再将 mark 所在位置的元素和遍历到的元素交换位置，mark 这个位置存储的是比基准值小的数据，当遍历结束后，将基准值与 mark 所在元素交换位置即可。 </p>
<pre><code>public static void sort(int[] arr) {
    sort(arr， 0， arr.length - 1);
}

private static void sort(int[] arr， int startIndex， int endIndex) {
    if (endIndex &lt;= startIndex) {
        return;
    }
    //切分
    int pivotIndex = partitionV2(arr， startIndex， endIndex);
    sort(arr， startIndex， pivotIndex-1);
    sort(arr， pivotIndex+1， endIndex);
}

private static int partition(int[] arr， int startIndex， int endIndex) {
    int pivot = arr[startIndex];//取基准值
    int mark = startIndex;//Mark初始化为起始下标

    for(int i=startIndex+1; i&lt;=endIndex; i++){
        if(arr[i]&lt;pivot){
            //小于基准值 则mark+1，并交换位置。
            mark ++;
            int p = arr[mark];
            arr[mark] = arr[i];
            arr[i] = p;
        }
    }
    //基准值与mark对应元素调换位置
    arr[startIndex] = arr[mark];
    arr[mark] = pivot;
    return mark;
}
</code></pre><p>双边扫描：<br>另外还有一种双边扫描的做法，看起来比较直观：我们随意抽取一个数作为基准值，然后从数组左右两边进行扫描，先从左往右找到一个大于基准值的元素，将下标指针记录下来，然后转到从右往左扫描，找到一个小于基准值的元素，交换这两个元素的位置，重复步骤，直到左右两个指针相遇，再将基准值与左侧最右边的元素交换。</p>
<p>我们来看一下实现代码，不同之处只有 partition 方法：<br>    public static void sort(int[] arr) {<br>        sort(arr， 0， arr.length - 1);<br>    }</p>
<pre><code>private static void sort(int[] arr， int startIndex， int endIndex) {
    if (endIndex &lt;= startIndex) {
        return;
    }
    //切分
    int pivotIndex = partition(arr， startIndex， endIndex);
    sort(arr， startIndex， pivotIndex-1);
    sort(arr， pivotIndex+1， endIndex);
}


private static int partition(int[] arr， int startIndex， int endIndex) {
    int left = startIndex;
    int right = endIndex;
    int pivot = arr[startIndex];//取第一个元素为基准值

    while (true) {
        //从左往右扫描
        while (arr[left] &lt;= pivot) {
            left++;
            if (left == right) {
                break;
            }
        }

        //从右往左扫描
        while (pivot &lt; arr[right]) {
            right--;
            if (left == right) {
                break;
            }
        }

        //左右指针相遇
        if (left &gt;= right) {
            break;
        }

        //交换左右数据
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
    }

    //将基准值插入序列
    int temp = arr[startIndex];
    arr[startIndex] = arr[right];
    arr[right] = temp;
    return right;
} 
</code></pre><p>极端情况：<br>快速排序的时间复杂度和归并排序一样，O(n log n)，但这是建立在每次切分都能把数组一刀切两半差不多大的前提下，如果出现极端情况，比如排一个有序的序列，如[ 9，8，7，6，5，4，3，2，1 ]，选取基准值 9 ，那么需要切分 n - 1 次才能完成整个快速排序的过程，这种情况下，时间复杂度就退化成了 O(n2)，当然极端情况出现的概率也是比较低的。</p>
<p>所以说，快速排序的时间复杂度是 O(nlogn)，极端情况下会退化成 O(n2)，为了避免极端情况的发生，选取基准值应该做到随机选取，或者是打乱一下数组再选取。</p>
<p>另外，快速排序的空间复杂度为 O(1)。 </p>
<p><strong><em><code>No.7 堆排序</code></em></strong></p>
<p>堆排序顾名思义，是利用堆这种数据结构来进行排序的算法。</p>
<p>如果你不了解堆这种数据结构，可以查看小吴之前的数据结构系列文章—看动画轻松理解堆</p>
<p>如果你了解堆这种数据结构，你应该知道堆是一种优先队列，两种实现，最大堆和最小堆，由于我们这里排序按升序排，所以就直接以最大堆来说吧。</p>
<p>我们完全可以把堆（以下全都默认为最大堆）看成一棵完全二叉树，但是位于堆顶的元素总是整棵树的最大值，每个子节点的值都比父节点小，由于堆要时刻保持这样的规则特性，所以一旦堆里面的数据发生变化，我们必须对堆重新进行一次构建。</p>
<p>既然堆顶元素永远都是整棵树中的最大值，那么我们将数据构建成堆后，只需要从堆顶取元素不就好了吗？ 第一次取的元素，是否取的就是最大值？取完后把堆重新构建一下，然后再取堆顶的元素，是否取的就是第二大的值？ 反复的取，取出来的数据也就是有序的数据。<br> <img src="/my-blog/2019/06/14/十大排序算法/堆排序.gif" alt="排序"> </p>
<pre><code>[ 8，2，5，9，7，3 ]
public static void sort(int[] arr) {
    int length = arr.length;
    //构建堆
    buildHeap(arr， length);
    for ( int i = length - 1; i &gt; 0; i-- ) {
        //将堆顶元素与末位元素调换
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        //数组长度-1 隐藏堆尾元素
        length--;
        //将堆顶元素下沉 目的是将最大的元素浮到堆顶来
        sink(arr， 0， length);
    }
}
private static void buildHeap(int[] arr， int length) {
    for (int i = length / 2; i &gt;= 0; i--) {
        sink(arr， i， length);
    }
}

/**
 * 下沉调整
 * @param arr 数组
 * @param index 调整位置
 * @param length 数组范围
 */
private static void sink(int[] arr， int index， int length) {
    int leftChild = 2 * index + 1;//左子节点下标
    int rightChild = 2 * index + 2;//右子节点下标
    int present = index;//要调整的节点下标

    //下沉左边
    if (leftChild &lt; length &amp;&amp; arr[leftChild] &gt; arr[present]) {
        present = leftChild;
    }

    //下沉右边
    if (rightChild &lt; length &amp;&amp; arr[rightChild] &gt; arr[present]) {
        present = rightChild;
    }

    //如果下标不相等 证明调换过了
    if (present != index) {
        //交换值
        int temp = arr[index];
        arr[index] = arr[present];
        arr[present] = temp;

        //继续下沉
        sink(arr， present， length);
    }
}
</code></pre><p>堆排序和快速排序的时间复杂度都一样是 O(nlogn)。</p>
<p><strong><em><code>No.8 计数排序</code></em></strong></p>
<p>计数排序是一种非基于比较的排序算法，我们之前介绍的各种排序算法几乎都是基于元素之间的比较来进行排序的，计数排序的时间复杂度为 O(n + m )，m 指的是数据量，说的简单点，计数排序算法的时间复杂度约等于 O(n)，快于任何比较型的排序算法。<br> <img src="/my-blog/2019/06/14/十大排序算法/计数排序.gif" alt="排序"> </p>
<pre><code>[ 3，5，8，2，5，4 ]
public static void sort(int[] arr) {
    //找出数组中的最大值
    int max = arr[0];
    for (int i = 1; i &lt; arr.length; i++) {
        if (arr[i] &gt; max) {
            max = arr[i];
        }
    }
    //初始化计数数组
    int[] countArr = new int[max + 1];

    //计数
    for (int i = 0; i &lt; arr.length; i++) {
        countArr[arr[i]]++;
        arr[i] = 0;
    }

    //排序
    int index = 0;
    for (int i = 0; i &lt; countArr.length; i++) {
        if (countArr[i] &gt; 0) {
            arr[index++] = i;
        }
    }
}  
</code></pre><p><strong><em><code>No.9 桶排序</code></em></strong></p>
<p>桶排序可以看成是计数排序的升级版，它将要排的数据分到多个有序的桶里，每个桶里的数据再单独排序，再把每个桶的数据依次取出，即可完成排序。<br> <img src="/my-blog/2019/06/14/十大排序算法/桶排序.gif" alt="排序"> </p>
<pre><code>[ 500，6123，1700，10，9999 ]

public static void sort(int[] arr){
    //最大最小值
    int max = arr[0];
    int min = arr[0];
    int length = arr.length;

    for(int i=1; i&lt;length; i++) {
        if(arr[i] &gt; max) {
            max = arr[i];
        } else if(arr[i] &lt; min) {
            min = arr[i];
        }
    }

    //最大值和最小值的差
    int diff = max - min;

    //桶列表
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;&gt;();
    for(int i = 0; i &lt; length; i++){
        bucketList.add(new ArrayList&lt;&gt;());
    }

    //每个桶的存数区间
    float section = (float) diff / (float) (length - 1);

    //数据入桶
    for(int i = 0; i &lt; length; i++){
        //当前数除以区间得出存放桶的位置 减1后得出桶的下标
        int num = (int) (arr[i] / section) - 1;
        if(num &lt; 0){
            num = 0;
        }
        bucketList.get(num).add(arr[i]);
    }

    //桶内排序
    for(int i = 0; i &lt; bucketList.size(); i++){
        //jdk的排序速度当然信得过
        Collections.sort(bucketList.get(i));
    }

    //写入原数组
    int index = 0;
    for(ArrayList&lt;Integer&gt; arrayList : bucketList){
        for(int value : arrayList){
            arr[index] = value;
            index++;
        }
    }
}
</code></pre><p>桶当然是一个可以存放数据的集合，我这里使用 arrayList ，如果你使用 LinkedList 那其实也是没有问题的。</p>
<p>桶的数量我认为设置为原数组的长度是合理的，因为理想情况下每个数据装一个桶。</p>
<p>数据入桶的映射算法其实是一个开放性问题，我承认我这里写的方案并不佳，因为我测试过不同的数据集合来排序，如果你有什么更好的方案或想法，欢迎留言讨论。</p>
<p>桶内排序为了方便起见使用了当前语言提供的排序方法，如果对于稳定排序有所要求，可以选择使用自定义的排序算法。</p>
<p><strong><em><code>No.10 基数排序</code></em></strong></p>
<p>基数排序是一种非比较型整数排序算法，其原理是将数据按位数切割成不同的数字，然后按每个位数分别比较。<br>假设说，我们要对 100 万个手机号码进行排序，应该选择什么排序算法呢？排的快的有归并、快排时间复杂度是 O(nlogn)，计数排序和桶排序虽然更快一些，但是手机号码位数是11位，那得需要多少桶？内存条表示不服。</p>
<p>这个时候，我们使用基数排序是最好的选择。<br> <img src="/my-blog/2019/06/14/十大排序算法/基数排序.gif" alt="排序"> </p>
<pre><code>[ 892， 846， 821， 199， 810，700 ]

public static void sort(int[] arr){
    int length = arr.length;

    //最大值
    int max = arr[0];
    for(int i = 0;i &lt; length;i++){
        if(arr[i] &gt; max){
            max = arr[i];
        }
    }
    //当前排序位置
    int location = 1;

    //桶列表
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;&gt;();

    //长度为10 装入余数0-9的数据
    for(int i = 0; i &lt; 10; i++){
        bucketList.add(new ArrayList());
    }

    while(true)
    {
        //判断是否排完
        int dd = (int)Math.pow(10，(location - 1));
        if(max &lt; dd){
            break;
        }

        //数据入桶
        for(int i = 0; i &lt; length; i++)
        {
            //计算余数 放入相应的桶
            int number = ((arr[i] / dd) % 10);
            bucketList.get(number).add(arr[i]);
        }

        //写回数组
        int nn = 0;
        for (int i=0;i&lt;10;i++){
            int size = bucketList.get(i).size();
            for(int ii = 0;ii &lt; size;ii ++){
                arr[nn++] = bucketList.get(i).get(ii);
            }
            bucketList.get(i).clear();
        }
        location++;
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xiajuwei.github.io/my-blog/2019/06/14/十大排序算法/" data-id="ck3o7yf060006m8vc6h4t4kwp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-springclou配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/05/31/springclou配置/" class="article-date">
  <time datetime="2019-05-31T02:51:50.000Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/05/31/springclou配置/">springclou配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Eureka 常用配置及说明<br><a href="https://blog.csdn.net/asdfsadfasdfsa/article/details/79282036" target="_blank" rel="noopener">https://blog.csdn.net/asdfsadfasdfsa/article/details/79282036</a></p>
<p>Eureka 剔除失效服务<br><a href="https://www.cnblogs.com/jtlgb/p/9376168.html" target="_blank" rel="noopener">https://www.cnblogs.com/jtlgb/p/9376168.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xiajuwei.github.io/my-blog/2019/05/31/springclou配置/" data-id="ck3o7yf080007m8vcotaxjq44" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-将对象用作Map中的key" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/05/31/将对象用作Map中的key/" class="article-date">
  <time datetime="2019-05-31T02:03:36.000Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/05/31/将对象用作Map中的key/">将对象用作Map中的key</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果将对象作为Map中的key，需要是实现该对象的equals方法和hashCode方法；现在一般通过lombok可以简单得实现，并且可以选择具体需要哪些字段参与equals和hashCode方法的计算。</p>
<p>Java类型系统中分为基础类型和引用类型，引用类型中所有的对象都有一个父类——java.lang.Object。基类Object提供了一些可扩展的方法：equals、hashCode、toString、clone和finalize。开发者在覆盖这些方法的时候，要遵循一定的约定，如果使用不当就会造成bug。</p>
<p>equals 方法</p>
<p>如果类有自己的“逻辑相等”概念，而且父类的equals方法又无法满足期望的时候，就应该覆盖equals方法。在开发中我们有时候会将一个自定义的对象作为map中的key，或者将一个自定义的对象加入到集合中，这时候就需要覆盖equals方法。</p>
<p>hashCode方法</p>
<p>覆盖equals方法的时候，要同时覆盖hashCode方法。这里一起看一个案例。假设我定义一个用户信息类，代码如下所示：</p>
<p><img src="/my-blog/2019/05/31/将对象用作Map中的key/hashCode方法.jpg" alt="hashCode方法"></p>
<p>这里使用@EqualsAndHashCode注解生成equals和hashCode方法，并排除了除userId以外的其他字段，表示该用户信息对象的唯一性只跟userId这个字段有关。如果该类是继承了某个自定义的类，需要考虑父类的字段，那么还可以使用@EqualsAndHashCode中的callSuper字段，设置为true就会连父类的字段一起考虑，默认是只考虑当前类中的字段。关注lombok的用法，这里不展开讲了。</p>
<p>假设有一个场景，需要过滤确保某个列表里的用户对象是没有重复的，那么我们就需要确定用户对象的唯一id是什么？在这里是userId，可以使用集合来进行重复对象的过滤，代码如下所示：</p>
<p><img src="/my-blog/2019/05/31/将对象用作Map中的key/重复集合.jpg" alt="hashCode方法"></p>
<p>所有自定义的类都要覆盖toString方法，我会使用lombok的@ToString注解来帮我生成toString方法。使用toString方法可以将对象的字段都以可读的形式展示出来。这样在打印日志的时候，要打印某个对象，就不会打印出一个对象的地址，类似于UserInfo@1768b4，这种展示出来对排查问题一点帮助没有。</p>
<p>clone方法</p>
<p>我在开发中没有用过这个方法。要完成对象的拷贝，只需要区分自己是要深拷贝还是浅拷贝。一般我会使用拷贝构造器或静态工厂方法作为替代方案。</p>
<p>finalize</p>
<p>根据Java文档，finalize方法被设计出来是用于释放非Java资源，但是由于jvm的运行机制导致有很大可能不会调用到对象的finalize方法，或者调用的时机和顺序是不确定的，所以这个方法并没有达到其设计目标。Java9中这个方法已经被废弃了，不过现在很多面试还是会问到这个方法背后的原理，需要理解几个概念：<br>自定义类的对象，就是我们自定义的类，该类覆盖了finalize方法；<br>Finalizer对象，在新建一个覆盖了finalize方法的类的对象的时候，就会伴生一个Finalizer对象，并将该对象加入到一个双向列表中；<br>ReferenceQueuequeue，Finalizer对象创建出来后，就会被加入到这个双向列表；<br>FinalizerThread对象，Finalizer线程是3号线程，它的作用就是不断从上面哪个队列中取Finalizer对象，然后调用它的runFinalzier方法。</p>
<p>在Java应用中，如果对finalize方法使用不合理，有时候会引发一类问题——存放Finalizer的双向列表过长，导致一些对象的finalze方法调用延迟，如果程序在这个方法中进行了某些对时间敏感的资源的释放，那么就会有问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xiajuwei.github.io/my-blog/2019/05/31/将对象用作Map中的key/" data-id="ck3o7yf0c000am8vc5r79lrwo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-常用JSON库性能比较" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/05/31/常用JSON库性能比较/" class="article-date">
  <time datetime="2019-05-31T01:43:39.000Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/05/31/常用JSON库性能比较/">常用JSON库性能比较</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JSON不管是在Web开发还是服务器开发中是相当常见的数据传输格式，一般情况我们对于JSON解析构造的性能并不需要过于关心，除非是在性能要求比较高的系统。</p>
<p>目前对于Java开源的JSON类库有很多种，下面我们取4个常用的JSON库进行性能测试对比， 同时根据测试结果分析如果根据实际应用场景选择最合适的JSON库。</p>
<p>这4个JSON类库分别为：Gson，FastJson，Jackson，Json-lib。</p>
<p>简单介绍</p>
<p>选择一个合适的JSON库要从多个方面进行考虑：</p>
<p>字符串解析成JSON性能<br>字符串解析成JavaBean性能<br>JavaBean构造JSON性能<br>集合构造JSON性能<br>易用性<br>先简单介绍下四个类库的身份背景。</p>
<p>Gson</p>
<p>项目地址：<a href="https://github.com/google/gson" target="_blank" rel="noopener">https://github.com/google/gson</a><br>Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，但自从在2008年五月公开发布第一版后已被许多公司或用户应用。Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。在使用这种对象转换之前，需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。类里面只要有get和set方法，Gson完全可以实现复杂类型的json到bean或bean到json的转换，是JSON解析的神器。</p>
<p>FastJson</p>
<p>项目地址：<a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">https://github.com/alibaba/fastjson</a><br>Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，能够直接跑在JDK上。FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。</p>
<p>Jackson</p>
<p>项目地址：<a href="https://github.com/FasterXML/jackson" target="_blank" rel="noopener">https://github.com/FasterXML/jackson</a><br>Jackson是当前用的比较广泛的，用来序列化和反序列化json的Java开源框架。Jackson社区相对比较活跃，更新速度也比较快， 从Github中的统计来看，Jackson是最流行的json解析器之一，Spring MVC的默认json解析器便是Jackson。</p>
<p>Jackson优点很多：</p>
<p>Jackson 所依赖的jar包较少，简单易用。<br>与其他 Java 的 json 的框架 Gson 等相比，Jackson 解析大的 json 文件速度比较快。<br>Jackson 运行时占用内存比较低，性能比较好<br>Jackson 有灵活的 API，可以很容易进行扩展和定制。<br>目前最新版本是2.9.4，Jackson 的核心模块由三部分组成：</p>
<p>jackson-core 核心包，提供基于”流模式”解析的相关 API，它包括 JsonPaser 和 JsonGenerator。Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json。<br>jackson-annotations 注解包，提供标准注解功能；<br>jackson-databind 数据绑定包，提供基于”对象绑定” 解析的相关 API（ ObjectMapper ）和”树模型” 解析的相关 API（JsonNode）；基于”对象绑定” 解析的 API 和”树模型”解析的 API 依赖基于”流模式”解析的 API。</p>
<p>Json-lib</p>
<p>项目地址：<a href="http://json-lib.sourceforge.net/index.html" target="_blank" rel="noopener">http://json-lib.sourceforge.net/index.html</a><br>json-lib最开始的也是应用最广泛的json解析工具，json-lib 不好的地方确实是依赖于很多第三方包，对于复杂类型的转换，json-lib对于json转换成bean还有缺陷， 比如一个类里面会出现另一个类的list或者map集合，json-lib从json到bean的转换就会出现问题。json-lib在功能和性能上面都不能满足现在互联网化的需求。</p>
<p>编写性能测试</p>
<p>接下来开始编写这四个库的性能测试代码。</p>
<p>添加maven依赖</p>
<p>当然首先是添加四个库的maven依赖，公平起见，我全部使用它们最新的版本：</p>
<pre><code>&lt;!-- Json libs--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;
    &lt;artifactId&gt;json-lib&lt;/artifactId&gt;
    &lt;version&gt;2.4&lt;/version&gt;
    &lt;classifier&gt;jdk15&lt;/classifier&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
    &lt;artifactId&gt;gson&lt;/artifactId&gt;
    &lt;version&gt;2.8.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.46&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
    &lt;version&gt;2.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>四个库的工具类</p>
<p>FastJsonUtil.java</p>
<pre><code>public class FastJsonUtil {
    public static String bean2Json(Object obj) {
        return JSON.toJSONString(obj);
    }
    public static &lt;T&gt; T json2Bean(String jsonStr, Class&lt;T&gt; objClass) {
        return JSON.parseObject(jsonStr, objClass);
    }
}
</code></pre><p>GsonUtil.java</p>
<pre><code>public class GsonUtil {
    private static Gson gson = new GsonBuilder().create();

    public static String bean2Json(Object obj) {
        return gson.toJson(obj);
    }

    public static &lt;T&gt; T json2Bean(String jsonStr, Class&lt;T&gt; objClass) {
        return gson.fromJson(jsonStr, objClass);
    }

    public static String jsonFormatter(String uglyJsonStr) {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        JsonParser jp = new JsonParser();
        JsonElement je = jp.parse(uglyJsonStr);
        return gson.toJson(je);
    }
}
</code></pre><p>JacksonUtil.java</p>
<pre><code>public class JacksonUtil {

    private static ObjectMapper mapper = new ObjectMapper();
    public static String bean2Json(Object obj) {
        try {
            return mapper.writeValueAsString(obj);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static &lt;T&gt; T json2Bean(String jsonStr, Class&lt;T&gt; objClass) {
        try {
            return mapper.readValue(jsonStr, objClass);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}
</code></pre><p>JsonLibUtil.java</p>
<pre><code>public class JsonLibUtil {

    public static String bean2Json(Object obj) {
        JSONObject jsonObject = JSONObject.fromObject(obj);
        return jsonObject.toString();
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T json2Bean(String jsonStr, Class&lt;T&gt; objClass) {
        return (T) JSONObject.toBean(JSONObject.fromObject(jsonStr), objClass);
    }
}
</code></pre><p>准备Model类</p>
<p>这里我写一个简单的Person类，同时属性有Date、List、Map和自定义的类FullName，最大程度模拟真实场景。</p>
<pre><code>public class Person {
    private String name;
    private FullName fullName;
    private int age;
    private Date birthday;
    private List&lt;String&gt; hobbies;
    private Map&lt;String, String&gt; clothes;
    private List&lt;Person&gt; friends;
    // getter/setter省略
    @Override
    public String toString() {
        StringBuilder str = new StringBuilder(&quot;Person [name=&quot; + name + &quot;, fullName=&quot; + fullName + &quot;, age=&quot;
                + age + &quot;, birthday=&quot; + birthday + &quot;, hobbies=&quot; + hobbies
                + &quot;, clothes=&quot; + clothes + &quot;]
&quot;);
        if (friends != null) {
            str.append(&quot;Friends:
&quot;);
            for (Person f : friends) {
                str.append(&quot;    &quot;).append(f);
            }
        }
        return str.toString();
    }

}
public class FullName {
    private String firstName;
    private String middleName;
    private String lastName;

    public FullName() {
    }
    public FullName(String firstName, String middleName, String lastName) {
        this.firstName = firstName;
        this.middleName = middleName;
        this.lastName = lastName;
    }
    // 省略getter和setter
    @Override
    public String toString() {
        return &quot;[firstName=&quot; + firstName + &quot;, middleName=&quot;
                + middleName + &quot;, lastName=&quot; + lastName + &quot;]&quot;;
    }
}
</code></pre><p>JSON序列化性能基准测试</p>
<pre><code>@BenchmarkMode(Mode.SingleShotTime)
@OutputTimeUnit(TimeUnit.SECONDS)
@State(Scope.Benchmark)
public class JsonSerializeBenchmark {
    /**
     * 序列化次数参数
     */
    @Param({&quot;1000&quot;, &quot;10000&quot;, &quot;100000&quot;})
    private int count;

    private Person p;

    public static void main(String[] args) throws Exception {
        Options opt = new OptionsBuilder()
                .include(JsonSerializeBenchmark.class.getSimpleName())
                .forks(1)
                .warmupIterations(0)
                .build();
        Collection&lt;RunResult&gt; results =  new Runner(opt).run();
        ResultExporter.exportResult(&quot;JSON序列化性能&quot;, results, &quot;count&quot;, &quot;秒&quot;);
    }

    @Benchmark
    public void JsonLib() {
        for (int i = 0; i &lt; count; i++) {
            JsonLibUtil.bean2Json(p);
        }
    }

    @Benchmark
    public void Gson() {
        for (int i = 0; i &lt; count; i++) {
            GsonUtil.bean2Json(p);
        }
    }

    @Benchmark
    public void FastJson() {
        for (int i = 0; i &lt; count; i++) {
            FastJsonUtil.bean2Json(p);
        }
    }

    @Benchmark
    public void Jackson() {
        for (int i = 0; i &lt; count; i++) {
            JacksonUtil.bean2Json(p);
        }
    }

    @Setup
    public void prepare() {
        List&lt;Person&gt; friends=new ArrayList&lt;Person&gt;();
        friends.add(createAPerson(&quot;小明&quot;,null));
        friends.add(createAPerson(&quot;Tony&quot;,null));
        friends.add(createAPerson(&quot;陈小二&quot;,null));
        p=createAPerson(&quot;邵同学&quot;,friends);
    }

    @TearDown
    public void shutdown() {
    }

    private Person createAPerson(String name,List&lt;Person&gt; friends) {
        Person newPerson=new Person();
        newPerson.setName(name);
        newPerson.setFullName(new FullName(&quot;zjj_first&quot;, &quot;zjj_middle&quot;, &quot;zjj_last&quot;));
        newPerson.setAge(24);
        List&lt;String&gt; hobbies=new ArrayList&lt;String&gt;();
        hobbies.add(&quot;篮球&quot;);
        hobbies.add(&quot;游泳&quot;);
        hobbies.add(&quot;coding&quot;);
        newPerson.setHobbies(hobbies);
        Map&lt;String,String&gt; clothes=new HashMap&lt;String, String&gt;();
        clothes.put(&quot;coat&quot;, &quot;Nike&quot;);
        clothes.put(&quot;trousers&quot;, &quot;adidas&quot;);
        clothes.put(&quot;shoes&quot;, &quot;安踏&quot;);
        newPerson.setClothes(clothes);
        newPerson.setFriends(friends);
        return newPerson;
    }
}
</code></pre><p>说明一下，上面的代码中</p>
<pre><code>ResultExporter.exportResult(&quot;JSON序列化性能&quot;, results, &quot;count&quot;, &quot;秒&quot;);
</code></pre><p>这个是我自己编写的将性能测试报告数据填充至Echarts图，然后导出png图片的方法。</p>
<p>执行后的结果图：</p>
<p><img src="/my-blog/2019/05/31/常用JSON库性能比较/JSON序列化性能.jpg" alt="JSON序列化性能"></p>
<p>从上面的测试结果可以看出，序列化次数比较小的时候，Gson性能最好，当不断增加的时候到了100000，Gson明细弱于Jackson和FastJson， 这时候FastJson性能是真的牛，另外还可以看到不管数量少还是多，Jackson一直表现优异。而那个Json-lib简直就是来搞笑的。^_^</p>
<p>JSON反序列化性能基准测试</p>
<pre><code>@BenchmarkMode(Mode.SingleShotTime)
@OutputTimeUnit(TimeUnit.SECONDS)
@State(Scope.Benchmark)
public class JsonDeserializeBenchmark {
    /**
     * 反序列化次数参数
     */
    @Param({&quot;1000&quot;, &quot;10000&quot;, &quot;100000&quot;})
    private int count;

    private String jsonStr;

    public static void main(String[] args) throws Exception {
        Options opt = new OptionsBuilder()
                .include(JsonDeserializeBenchmark.class.getSimpleName())
                .forks(1)
                .warmupIterations(0)
                .build();
        Collection&lt;RunResult&gt; results =  new Runner(opt).run();
        ResultExporter.exportResult(&quot;JSON反序列化性能&quot;, results, &quot;count&quot;, &quot;秒&quot;);
    }

    @Benchmark
    public void JsonLib() {
        for (int i = 0; i &lt; count; i++) {
            JsonLibUtil.json2Bean(jsonStr, Person.class);
        }
    }

    @Benchmark
    public void Gson() {
        for (int i = 0; i &lt; count; i++) {
            GsonUtil.json2Bean(jsonStr, Person.class);
        }
    }

    @Benchmark
    public void FastJson() {
        for (int i = 0; i &lt; count; i++) {
            FastJsonUtil.json2Bean(jsonStr, Person.class);
        }
    }

    @Benchmark
    public void Jackson() {
        for (int i = 0; i &lt; count; i++) {
            JacksonUtil.json2Bean(jsonStr, Person.class);
        }
    }

    @Setup
    public void prepare() {
        jsonStr=&quot;{&quot;name&quot;:&quot;邵同学&quot;,&quot;fullName&quot;:{&quot;firstName&quot;:&quot;zjj_first&quot;,&quot;middleName&quot;:&quot;zjj_middle&quot;,&quot;lastName&quot;:&quot;zjj_last&quot;},&quot;age&quot;:24,&quot;birthday&quot;:null,&quot;hobbies&quot;:[&quot;篮球&quot;,&quot;游泳&quot;,&quot;coding&quot;],&quot;clothes&quot;:{&quot;shoes&quot;:&quot;安踏&quot;,&quot;trousers&quot;:&quot;adidas&quot;,&quot;coat&quot;:&quot;Nike&quot;},&quot;friends&quot;:[{&quot;name&quot;:&quot;小明&quot;,&quot;fullName&quot;:{&quot;firstName&quot;:&quot;xxx_first&quot;,&quot;middleName&quot;:&quot;xxx_middle&quot;,&quot;lastName&quot;:&quot;xxx_last&quot;},&quot;age&quot;:24,&quot;birthday&quot;:null,&quot;hobbies&quot;:[&quot;篮球&quot;,&quot;游泳&quot;,&quot;coding&quot;],&quot;clothes&quot;:{&quot;shoes&quot;:&quot;安踏&quot;,&quot;trousers&quot;:&quot;adidas&quot;,&quot;coat&quot;:&quot;Nike&quot;},&quot;friends&quot;:null},{&quot;name&quot;:&quot;Tony&quot;,&quot;fullName&quot;:{&quot;firstName&quot;:&quot;xxx_first&quot;,&quot;middleName&quot;:&quot;xxx_middle&quot;,&quot;lastName&quot;:&quot;xxx_last&quot;},&quot;age&quot;:24,&quot;birthday&quot;:null,&quot;hobbies&quot;:[&quot;篮球&quot;,&quot;游泳&quot;,&quot;coding&quot;],&quot;clothes&quot;:{&quot;shoes&quot;:&quot;安踏&quot;,&quot;trousers&quot;:&quot;adidas&quot;,&quot;coat&quot;:&quot;Nike&quot;},&quot;friends&quot;:null},{&quot;name&quot;:&quot;陈小二&quot;,&quot;fullName&quot;:{&quot;firstName&quot;:&quot;xxx_first&quot;,&quot;middleName&quot;:&quot;xxx_middle&quot;,&quot;lastName&quot;:&quot;xxx_last&quot;},&quot;age&quot;:24,&quot;birthday&quot;:null,&quot;hobbies&quot;:[&quot;篮球&quot;,&quot;游泳&quot;,&quot;coding&quot;],&quot;clothes&quot;:{&quot;shoes&quot;:&quot;安踏&quot;,&quot;trousers&quot;:&quot;adidas&quot;,&quot;coat&quot;:&quot;Nike&quot;},&quot;friends&quot;:null}]}&quot;;
    }

    @TearDown
    public void shutdown() {
    }
}
</code></pre><p>执行后的结果图：</p>
<p><img src="/my-blog/2019/05/31/常用JSON库性能比较/JSON反序列化性能.jpg" alt="JSON反序列化性能"></p>
<p>从上面的测试结果可以看出，反序列化的时候，Gson、Jackson和FastJson区别不大，性能都很优异。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xiajuwei.github.io/my-blog/2019/05/31/常用JSON库性能比较/" data-id="ck3o7yf16000bm8vcb5ed5ofm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/my-blog/page/2/">2</a><a class="extend next" rel="next" href="/my-blog/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/my-blog/2019/12/02/lambda使用/">lambda使用</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/12/02/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/08/10/常用插件/">常用插件</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/07/02/redis/">redis</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/06/20/java-中的锁/">java 中的锁</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/my-blog/" class="mobile-nav-link">Home</a>
  
    <a href="/my-blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/my-blog/fancybox/jquery.fancybox.css">
  <script src="/my-blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/my-blog/js/script.js"></script>



  </div>
</body>
</html>